\documentclass{llncs}

\usepackage[usenames,dvipsnames]{color}

\usepackage{fancybox}
\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
% \usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{paralist}
\usepackage{graphics}
\usepackage{stmaryrd}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}

\usepackage{proof}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage[draft]{commenting}

\pagestyle{plain}

\include{commands}

\definecolor{darkgreen}{rgb}{0,0.6,0}
\declareauthor{ri}{Radu}{blue}
\declareauthor{ar}{Andy}{red}
\declareauthor{cs}{Cristina}{darkgreen}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Encoding Separation Logic in SMT-LIB v2.5}

\author{Radu Iosif\inst{2} \and Cristina Serban\inst{2} \and Andrew Reynolds\inst{1} \and Mihaela Sighireanu\inst{3}} 

\institute{The University of Iowa \and Verimag/CNRS/Universit\'e de Grenoble Alpes \and IRIF/Universit\'e Paris Diderot}

\maketitle

\begin{abstract}
  We propose an encoding of Separation Logic using SMT-LIB v2.5. This
  format is currently supported by SMT solvers (CVC4) and inductive
  proof-theoretic solvers (SLIDE and SPEN). Moreover, we provide a
  library of benchmarks written using this format, which stems from
  the set of benchmarks used in SL-COMP'14 \cite{sl-comp14}.
\end{abstract}

\section{Preliminaries}

We consider formulae in multi-sorted first-order logic.  A
\emph{signature} $\Sigma$ consists of a set $\ssorts{\Sigma}$ of sort
symbols and a set $\sfuns{\Sigma}$ of \emph{function symbols}
$f^{\sigma_1 \cdots \sigma_n \sigma}$, where $n \geq 0$ and $\sigma_1,
\ldots, \sigma_n, \sigma \in \ssorts{\Sigma}$. If $n=0$, we call
$f^\sigma$ a \emph{constant symbol}. We make the following
assumptions:
\begin{compactenum}
\item all signatures $\Sigma$ contain the Boolean sort $\bool$, where
  $\top$ and $\bot$ denote the Boolean constants \emph{true} and
  \emph{false}. 
\item $\sfuns{\Sigma}$ contains a boolean equality function
  $\teq^{\sigma\sigma\bool}$ for each sort symbol
  $\sigma\in\ssorts{\Sigma}$.
\end{compactenum}

Let $\vars$ be a countable set of first-order variables, each
$x^\sigma \in \vars$ having an associated sort $\sigma$. First-order
terms and formulae over the signature $\Sigma$ (called $\Sigma$-terms
and $\Sigma$-formulae) are defined as usual. A
\emph{$\Sigma$-interpretation $\I$} maps:\begin{compactitem}
\item each sort symbol $\sigma \in \Sigma$ to a non-empty set $\sigma^\I$,
\item each function symbol $f^{\sigma_1,\ldots,\sigma_n,\sigma} \in \Sigma$ to a
  total function $f^\I : \sigma^\I_1 \times \ldots \times \sigma^\I_n
  \rightarrow \sigma^\I$ where $n > 0$, and to an element of $\sigma^\I$ when $n
  = 0$, and
\item each variable $x^\sigma \in \vars$ to an element of $\sigma^\I$.
\end{compactitem}

For an interpretation $\I$ a sort symbol $\sigma$ and a variable $x$,
we denote by $\I[\sigma \leftarrow S]$ and, respectively $\I[x
  \leftarrow v]$, the interpretation associating the set $S$ to
$\sigma$, respectively the value $v$ to $x$, and which behaves like
$\I$ in all other cases. By writing $\I[\sigma \leftarrow S]$ we
ensure that all variables of sort $\sigma$ are mapped by $\I$ to
elements of $S$. For a $\Sigma$-term $t$, we write $t^\I$ to denote
the interpretation of $t$ in $\I$, defined inductively, as usual. A
satisfiability relation between $\Sigma$-interpretations and
$\Sigma$-formulas, written $\I \models \varphi$, is also defined
inductively, as usual. In this case, we say that $\I$ is a
\emph{model} of $\varphi$. 

A (multi-sorted first-order) \emph{theory} is a pair \(T = (\Sigma,
\mods)\) where $\Sigma$ is a signature and $\mods$ is a non-empty set
of $\Sigma$-interpretations, the \emph{models} of $T$. A
$\Sigma$-formula $\varphi$ is \emph{$T$-satisfiable} if it is
satisfied by some interpretation in $\mods$.

\section{Ground Separation Logic}

Let \(T = (\Sigma, \mods)\) be a theory and let $\locs$ and $\data$ be
two sorts from $\Sigma$, with no restriction other than the fact that
$\locs$ is always interpreted as a countable set. Also, we consider
that $\Sigma$ has a designated constant symbol $\nil^\locs$. We define
the \emph{Ground Separation Logic} $\seplog(T)^g_{\locs,\data}$ to
be the set of formulae generated by the following syntax:
\[\begin{array}{lcl}
\varphi & := & \phi \mid \emp \mid \tterm \mapsto \uterm \mid
\varphi_1 * \varphi_2 \mid \varphi_1 \wand \varphi_2 \mid \neg
\varphi_1 \mid \varphi_1 \wedge \varphi_2 \mid \exists x^\sigma ~.~
\varphi_1(x)
\end{array}\]
where $\phi$ is a $\Sigma$-formula, and $\tterm$, $\uterm$ are
$\Sigma$-terms of sorts $\locs$ and $\data$, respectively. As usual,
we write $\forall x^\sigma ~.~ \varphi(x)$ for $\neg\exists x^\sigma
~.~ \neg\varphi(x)$. We omit specifying the sorts of variables and
functions when they are clear from the context.

Given an interpretation $\I$, a \emph{heap} is a finite partial
mapping $h : \locs^\I \rightharpoonup_{\mathrm{fin}} \data^\I$. For a
heap $h$, we denote by $\dom(h)$ its domain. For two heaps $h_1$ and
$h_2$, we write $h_1 \# h_2$ for $\dom(h_1) \cap \dom(h_2) =
\emptyset$ and $h = h_1 \uplus h_2$ for $h_1 \# h_2$ and $h = h_1 \cup
h_2$. We define the \emph{satisfaction relation} $\I,h
\models_{\tinyseplog} \phi$ inductively, as follows:
\[\begin{array}{lcl}
\I,h \models_{\tinyseplog} \phi & \iff & \I \models \phi \text{ if $\phi$ is a $\Sigma$-formula} \\
\I,h \models_{\tinyseplog} \emp & \iff & h = \emptyset \\
\I,h \models_{\tinyseplog} \tterm \mapsto \uterm & \iff & 
h = \{(\tterm^\I,\uterm^\I)\} \text{ and } \tterm^\I\not\teq\nil^\I \\
\I,h \models_{\tinyseplog} \phi_1 * \phi_2 & \iff & \text{there exist heaps } h_1,h_2 
\text{ s.t. } h=h_1\uplus h_2 
\text{ and } \I,h_i \models_{\tinyseplog} \phi_i, i = 1,2 \\
\I,h \models_{\tinyseplog} \phi_1 \wand \phi_2 & \iff & \text{for all heaps } h' \text{ if } h'\#h 
\text{ and } \I,h' \models_{\tinyseplog} \phi_1
\text{ then } \I,h'\uplus h \models_{\tinyseplog} \phi_2 \\
\I,h \models_{\tinyseplog} \exists x^S . \varphi(x) & \iff & 
\I[x \leftarrow s],h \models_{\tinyseplog} \varphi(x) \text{, for some }s \in S^\I
\end{array}\]
The satisfaction relation for $\Sigma$-formulae, Boolean connectives
$\wedge$, $\neg$, and linear arithmetic atoms, are the classical ones
from first-order logic. Notice that the range of a quantified variable
$x^S$ is the interpretation of its associated sort $S^\I$. A formula
$\varphi$ is said to be \emph{satisfiable} if there exists an
interpretation $\I$ and a heap $h$ such that $\I,h
\models_{\tinyseplog} \varphi$. We say that $\varphi$ \emph{entails}
$\psi$, written $\varphi \models_{\tinyseplog} \psi$, when every pair
$(\I,h)$ which satisfies $\varphi$, also satisfies $\psi$.

\subsection{SMT-LIB Encoding}

We write ground $\seplog$ formulae in SMT-LIB using the following functions: 
\begin{center}
\shadowbox{
\begin{minipage}{7cm}
\begin{verbatim}
(emp Bool)
(sep Bool Bool Bool :left-assoc)
(wand Bool Bool Bool :right-assoc)
(par (Loc Data) (pto Loc Data Bool))
(par (Loc) (nil Loc))
\end{verbatim}
\end{minipage}}
\end{center}
Observe that {\tt pto} and {\tt nil} are polymorphic functions, with
sort parameters {\tt Loc} and {\tt Data}. There is no restriction on
the choice of {\tt Loc} and {\tt Data}, as shown below. 

\todo{Is {\tt nil} always of sort {\tt Loc} ? Here {\tt Loc} is just a parameter with no special meaning.}

Assume that {\tt Loc} is an uninterpreted sort $\mathsf{U}$, {\tt
  Data} is the integer sort $\Int$, and that $x^{\mathsf{U}}, y^{\mathsf{U}},
a^{\Int}$ and $b^{\Int}$ are constants: 
\begin{verbatim}
(declare-sort U 0)

(declare-const x U)
(declare-const y U)
(declare-const a Int)
(declare-const b Int)
\end{verbatim}
We write the $\seplog$ formula \(\emp \wedge ((x \mapsto a * y \mapsto
b) \wand (x \mapsto \nil * \top))\) in SMT-LIB as follows:
\begin{verbatim}
(and emp (wand (sep (pto x a) (pto y b)) (sep (pto x (as nil Int)) true)))
\end{verbatim}
In addition to the classical SMT-LIB typing constraints, the $\seplog$
theories require that the heap models are well-typed. For instance, a
separation constraint of the form: 
\begin{verbatim}
(sep (pto x y) (pto a b))
\end{verbatim}
with the above constant declarations results in a typing error,
because {\tt (pto x y)} requires the heap to be of type $\mathsf{U}
\rightharpoonup \mathsf{U}$, whereas {\tt (pto a b)} requires the heap
to be of type $\Int \rightharpoonup \Int$, and combining heaps of
different types is not allowed. 

\todo{
  \begin{compactenum} 
    \item It is currently unclear what the type of the heap introduced by
  {\tt emp} should be. The solution currently adopted in CVC4 is to
  give {\tt emp} parameters used only to infer the type, as in {\tt
    (emp x a)}. Another solution, used in SLIDE, is to infer the type
  of {\tt emp} based on the context. For instance the type of the {\tt
    emp} heap in {\tt (sep (pto x a) emp)} is $\mathsf{U}
  \rightharpoonup \Int$. We leave this point for discussion. 
  %
  \item It is usually expected that {\tt nil} be of type $\locs$,
    however currently one can force other type that $\locs$, like in
    the previous example. Shall we impose a stricter type checking on
    {\tt nil} ?
  \end{compactenum}
}

This heap typing restriction is not a limitation of the expressive
power of the SMT-LIB encoding and can be easily overcome by using
datatypes (available in SMT-LIB v2.5). Suppose, for instance that we
would like to specify a heap consisting of cells containing both
integer and boolean data. The idea is to declare a union type: 
\begin{verbatim}
(declare-datatype BoolInt ((cons_bool (d Bool)) (cons_int (d Int))))
\end{verbatim}
and use it to describe a mixed data heap, as in: 
\begin{verbatim}
(sep (pto x (cons_bool false)) (pto y (cons_int 0)))
\end{verbatim}
The same workaround can be used to specify heaps with mixed addresses,
although this is a much less common situation in practice. 

\subsection{Separation Logic with Inductive Definitions}

Let $\preds$ be a set of second-order variables, each $P^{\sigma_1
  \ldots \sigma_n} \in \preds$ having an associated tuple of parameter
sorts $\sigma_1, \ldots, \sigma_n \in \ssorts{\Sigma}$. In addition to
the first-order terms built using variables from $\vars$ and function
symbols from $\sfuns{\Sigma}$, we enrich the language of $\seplog$
with the boolean terms $P^{\sigma_1 \ldots \sigma_n}(t_1, \ldots,
t_n)$, where each $t_i$ is a first-order term of sort $\sigma_i$, for
$i=1,\ldots,n$. Each second-order variable $P^{\sigma_1 \ldots
  \sigma_n} \in \preds$ is provided with an inductive definition
$P(x_1,\ldots,x_n) \leftarrow \phi_P(x_1,\ldots,x_n)$, where $\phi_P$
is a formula in the extended language, possibly containing occurrences
of $P$. The satisfaction relation is then extended as follows:
\[\I,h \models_{\tinyseplog} P^{\sigma_1 \ldots \sigma_n}(t_1,\ldots,t_n) \iff 
\I,h \models_{\tinyseplog} \phi_P(t^\I_1,\ldots,t^I_n)\] where
$\phi_P$ is the inductive definition of $P^{\sigma_1 \ldots
  \sigma_n}$. Observe that, given a set of inductive definitions, the
set of possible models for each second-order variable is the least
fixed point of a monotonic and continuous function mapping tuples of
sets of models to a set of models.

\subsection{SMT-LIB Encoding}

An inductive definition $P(x_1,\ldots,x_n) \leftarrow
\phi_P(x_1,\ldots,x_n)$ is written in SMT-LIB using a recursive
function definition. For instance, the inductive definition of a 
doubly-linked list segment:
\[\begin{array}{rcl}
\mathsf{dllseg}(h, p, t, n) & \leftarrow & (\emp \wedge h \teq n \wedge p \teq t) ~\vee \\
&& (\exists x^{\locs} ~.~ h \mapsto (x,p) * \mathsf{dllseg}(x,h,t,n))
\end{array}\]
is written into SMT-LIB as follows: 
\begin{verbatim}
(declare-datatype Node ((node (next Loc) (prev Loc))))

(define-fun-rec dllseg ((h Loc) (p Loc) (t Loc) (n Loc)) Bool
    (or (and emp (= h n) (= p t))
        (exists ((x Loc)) (sep (pto h (node x p)) (dllseg x h t n)))
    )
)
\end{verbatim}

\subsection{A Detailed Example} 

Let us go through an example step by step. First of all, the preamble
of and SMT-LIB file describing a $\seplog$ satisfiability query must
contain (at least): 
\begin{verbatim}
(set-logic SEPLOG)
\end{verbatim}
Since $\seplog$ is used in combination with other theories, it is
customary to start with:
\begin{verbatim}
(set-logic ALL_SUPPORTED)
\end{verbatim}
We consider the slightly modified version of the $\mathsf{dllseg}$
definition above, which describes a doubly-linked list segment with
ordered integer data: 
\[\begin{array}{rcl}
\mathsf{dllseg}_{\mathit{ord}}(h, p, t, n, min) & \leftarrow & (\emp \wedge h \teq n \wedge p \teq t) ~\vee \\
&& (\exists x^{\locs} \exists d^{\Int} ~.~ h \mapsto (d,x,min) * \mathsf{dllseg}_{\mathit{ord}}(x,h,t,n,d)) \wedge min \leq d
\end{array}\]
Since we do not perform any pointer arithmetic reasoning, we can
declare $\locs$ to be an uninterpreted sort: 
\begin{verbatim}
(declare-sort U 0)
\end{verbatim}
We encode the definition of $\mathsf{dllseg}_{\mathit{ord}}$ as: 
\begin{verbatim}
(declare-datatype Node ((node (data Int) (next Loc) (prev Loc))))

(define-fun-rec dllseg_ord ((h Loc) (p Loc) (t Loc) (n Loc) (min Int)) Bool
    (or (and emp (= h n) (= p t))
        (exists ((x Loc) (d Int)) (and 
                                    (sep (pto h (node x p)) (dllseg_ord x h t n)) 
                                    (<= min d)
                                   )
        )
    )
)
\end{verbatim}
Let us consider the problem of proving that a
$\mathsf{dllseg}_{\mathit{ord}}$ to which a node is appended is again
a $\mathsf{dllseg}_{\mathit{ord}}$, provided that the data of the new
node it smaller than the minimal element of the first
$\mathsf{dllseg}_{\mathit{ord}}$:
\[x \mapsto (m,u,v) * \mathsf{dllseg}_{\mathit{ord}}(u,x,z,t,n) \wedge m \leq n
\models_{\tinyseplog} \mathsf{dllseg}_{\mathit{ord}}(x,y,z,t,m)\]
We encode this entailment problem as an assertion asking whether the negated problem is satisfiable:  
\begin{verbatim}
(declare-const x U)
(declare-const y U)
(declare-const z U)
(declare-const u U)
(declare-const v U)
(declare-const t U)
(declare-const m Int)
(declare-const n Int)

(assert (not (implies 
              (and (sep (pto x (node m u v)) (dllseg_ord u x z t n)) (<= m n)) 
              (dllseg_ord x y z t m)
             )
        )
)
\end{verbatim}
The entailment holds when the assertion is unsatisfiable, which can be
checked in the standard way, using {\tt (check-sat)}. However, the
dual problem:
\begin{verbatim}
(assert (not (implies 
              (dllseg_ord x y z t m)
              (and (sep (pto x (node m u v)) (dllseg_ord u x z t n)) (<= m n)) 
             )
        )
)
\end{verbatim}
is satisfiable, and the counter-model can be obtained in the standard
way, using {\tt (get-model)}. Observe that the model of a satisfiable
$\seplog$ query consists of an interpretation of the constants and a
specification of the heap. 

\section{Abduction and Frame Inference}

Abduction and frame inference (or bi-abduction for both) are problems
that occur in the context of program verification. In this case, the
solver is not only required to give a yes/no answer to a
satisfiability query, but to infer $\seplog$ formulae that ensure the
validity of a given entailment. Given $\seplog$ formulae $\varphi$ and
$\phi$, and second-order variables $X$ and $Y$, we consider the
following synthesis problems:

\todo{TO BE REFINED: what are the first-order parameters of $X$ and
  $Y$ ? It seems that $X$ is allowed to all free variables of
  $\varphi$, but how about $Y$ ? Is it allowed to all free variables
  of $\varphi$ and $\psi$, or just the ones of $\psi$ ?}

\begin{compactenum}
\item The \emph{abduction problem} asks for a satisfiable definition
  of a $X$ such that $\varphi * X \models_{\tinyseplog}
  \psi$. Sometimes $X$ is called an \emph{anti-frame}. Observe that $X
  \leftarrow \bot$ is always a solution, but not a very interesting
  one.
%
\item The \emph{frame inference problem} asks for a definition of $Y$
  such that $\varphi \models_{\tinyseplog} \psi * Y$.
%
\item The \emph{bi-abduction problem} asks for both a satisfiable
  definition of $X$ and a definition of $Y$ such that $\varphi * X
  \models_{\tinyseplog} \psi * Y$.
\end{compactenum}
The capability of solving the above problems is key to using a given
$\seplog$ solver for practical program verification purposes. For this
reason, we aim at finding a standard way of specifying these problems
in SMT-LIB.

\section{Additional Resources}

The quest for a suitable format for $\seplog$ solvers started with
SL-COMP'14 \cite{sl-comp14}, which adopted the {\tt QF\_S} format,
described in \cite{qfs}. The current proposal is inspired by {\tt
  QF\_S}, and relies on the datatypes introduced SMT-LIB v2.5 for an
elegant encoding of union and record types. The tools supporting
SMT-LIB as a native language are: \begin{compactitem}
\item CVC4 \cite{ReynoldsIosifKingSerban16} -- a description of the $\seplog$
  format of CVC4 is provided in \cite{cvc4-seplog} (a slightly
  modified version of the current proposal)
\item SLIDE (under construction) -- uses the encoding from the current
  proposal.
\item SPEN \cite{spen} -- a description of the $\seplog$
  format of SPEN ({\tt QF\_S}) is available in \cite{qfs}.
\end{compactitem} 
Other tools that participated to SL-COMP'14 have been adapted to {\tt
  QF\_S} by means of a specialized front-end \cite{qfs-frontend}. It
is our goal to convince the developpers of $\seplog$ solvers to adopt
SMT-LIB as the native input language of their tools. For this purpose,
we provide a C++ front-end \cite{smtlib-frontend} that can be used to
parse and type check $\seplog$ inputs encoded in SMT-LIB using the
current specification.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain} 
\bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
